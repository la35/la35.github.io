---
layout: post
title:  "Emulador de TOY-8"
author: "Santiago Trini"
categories: orga
tags: [orga,cpu]
image: pcb.jpg
date:   2020-06-22 13:40:00 -0300
---

En este [link](https://la35.github.io/emulador) pueden encontrar un emulador de TOY-8, una computadora super simple pero que ilustra perfectamente como una CPU ejecuta un programa desde la memoria. Todo el crédito de esta computadora es para Robert Sedgewick y Kevin Wayne, autores de [Computer Science: An Interdisciplinary Approach](https://www.amazon.com/Computer-Science-Interdisciplinary-Robert-Sedgewick/dp/0134076427/ref=sr_1_1?dchild=1&keywords=computer+science&qid=1592843578&s=books&sr=1-1), el manual de donde saqué esta computadora ficticia.

El emulador está re crudo todavía, cuando lo termine vuelvo a subir este post con muchos más detalles del funcionamiento de la CPU.

TOY-8 es una computadora con lo mínimo indispensable:

- Una memoria de 16 bytes, de los cuales solo 14 bytes están disponibles para el programador.
- Una CPU con un registro de propósito general (R) y una ALU con tres operaciones (suma, and y xor).
- Una sistema de E/S en binario al que se accede por medio de la dirección 15 de la memoria.

Las ocho instrucciones de TOY-8 son:

- **halt:** para la CPU (opcode 0).
- **add:** `R = R + M[addr]` (opcode 2).
- **and:** `R = R & M[addr]` (opcode 4).
- **xor:** `R = R ^ M[addr]` (opcode 6).
- **load address:** `R = addr` (opcode 8).
- **load word:** `R = M[addr]` (opcode A).
- **store word:** `M[addr] = R` (opcode C).
- **branch if zero:** `if (r == 0) PC = addr` (opcode E).

Las direcciones de memoria 0 y F (15) están reservadas. `M[0]` siempre vale cero y no se puede cambiar. La dirección de memoria F está conectada a la E/S, para leer un dato usamos `AF` y para imprimir un dato usamos `CF`.
